<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jajeczny Milioner ‚Äì LatajƒÖce Kurki Edition</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at top, #fdf6e3, #cbb48d);
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: "Comic Sans MS", cursive;
      height: 100vh;
      overflow: hidden;
      color: #333;
    }
    #gameContainer {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #gameCanvas {
      background: url('https://serwer2007468.home.pl/jajeczny/4381319.jpg') center/cover;
      border: 3px solid #333;
      border-radius: 1rem;
      box-shadow: inset 0 -3vw 3vw rgba(0, 0, 0, 0.3);
      aspect-ratio: 16 / 9;
      width: 90vw;
      max-width: 1000px;
      height: auto;
      display: block;
    }
    #chickensCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 5;
    }
    #hud {
      display: flex;
      justify-content: space-around;
      align-items: center;
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      font-size: 1.2rem;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 10;
    }
    #controls {
      display: flex;
      justify-content: space-between;
      width: 90%;
      max-width: 1000px;
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
    }
    .ctrl-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: none;
    }
    #startScreen, #gameOverScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 30px;
      border-radius: 12px;
      text-align: center;
      z-index: 20;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      margin-top: 15px;
    }
    button:hover { background: #45a049; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="level">Poziom: 1</div>
    <div id="score">Punkty: 0</div>
    <div id="lives">≈ªycia: 3</div>
  </div>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="960" height="540"></canvas>
    <canvas id="chickensCanvas" width="960" height="100"></canvas>
    <div id="controls">
      <div class="ctrl-btn" id="leftBtn">‚óÑ</div>
      <div class="ctrl-btn" id="rightBtn">‚ñ∫</div>
    </div>
  </div>
  <div id="startScreen">
    <h2>üê£ Jajeczny Milioner ü•ö</h2>
    <p>Z≈Çap jak najwiƒôcej jajek, unikajƒÖc ich upuszczenia!</p>
    <button id="startBtn">Start</button>
  </div>
  <div id="gameOverScreen" style="display:none">
    <h2>Koniec gry!</h2>
    <p>Tw√≥j wynik: <span id="finalScore"></span></p>
    <button id="restartBtn">Zagraj ponownie</button>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const chickenCanvas = document.getElementById('chickensCanvas');
    const cctx = chickenCanvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level');
    const livesDisplay = document.getElementById('lives');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScore = document.getElementById('finalScore');

    let score = 0, lives = 3, level = 1;
    let basketX, basketWidth, basketHeight, speed;
    const baseBasketWidth = 100;
    const poweredBasketWidth = 150;
    let eggs = [], hearts = [], goldenEggs = [], hourglasses = [], bigBaskets = [];
    let texts = [], chickens = [];
    let keys = { left: false, right: false };
    let gameRunning = false;
    const baseChickenCount = 2;
    const spawnChanceBase = 0.0012;
    const spawnChanceGrowth = 0.0003;
    const goldenEggChance = 0.12;
    const powerupChance = 0.003;
    let nextLevelScore = 50;
    let slowTimer = 0, bigTimer = 0;

    class Chicken {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = Math.random() * Math.PI * 2;
        this.direction = Math.random() < 0.5 ? 1 : -1;
      }
      update() {
        this.angle += 0.02;
        this.x += 1.2 * this.direction;
        this.y = 40 + Math.sin(this.angle) * 10;
        if (this.x < 50 || this.x > canvas.width - 50) this.direction *= -1;
        if (Math.random() < getCurrentSpawnChance()) spawnEggFromChicken(this.x);
      }
      draw() {
        cctx.beginPath();
        cctx.ellipse(this.x, this.y, 20, 15, 0, 0, Math.PI * 2);
        cctx.fillStyle = '#fff';
        cctx.fill();
        cctx.strokeStyle = '#aaa';
        cctx.stroke();
        cctx.beginPath();
        cctx.arc(this.x + 18 * this.direction, this.y - 5, 8, 0, Math.PI * 2);
        cctx.fillStyle = '#fff';
        cctx.fill();
        cctx.fillStyle = 'orange';
        cctx.beginPath();
        cctx.moveTo(this.x + 25 * this.direction, this.y - 5);
        cctx.lineTo(this.x + 35 * this.direction, this.y);
        cctx.lineTo(this.x + 25 * this.direction, this.y + 2);
        cctx.fill();
        cctx.fillStyle = 'red';
        cctx.beginPath();
        cctx.arc(this.x + 14 * this.direction, this.y - 14, 4, 0, Math.PI * 2);
        cctx.arc(this.x + 18 * this.direction, this.y - 16, 4, 0, Math.PI * 2);
        cctx.arc(this.x + 22 * this.direction, this.y - 14, 4, 0, Math.PI * 2);
        cctx.fill();
      }
    }

    function getCurrentSpawnChance() {
      return Math.min(0.01, spawnChanceBase + (level - 1) * spawnChanceGrowth);
    }

    function getChickenCountForLevel() {
      return baseChickenCount + (level - 1);
    }

    function spawnEggFromChicken(x) {
      const dy = 2 + Math.random();
      if (Math.random() < goldenEggChance) goldenEggs.push(new GoldenEgg(x, 100, dy));
      else eggs.push(new Egg(x, 100, dy));
      maybeSpawnPowerup(x);
    }

    function setupChickens() {
      const count = getChickenCountForLevel();
      const spacing = canvas.width / (count + 1);
      chickens = [];
      for (let i = 0; i < count; i++) {
        chickens.push(new Chicken(spacing * (i + 1), 40));
      }
    }

    function drawChickens() {
      cctx.clearRect(0, 0, chickenCanvas.width, chickenCanvas.height);
      chickens.forEach(ch => { ch.update(); ch.draw(); });
      requestAnimationFrame(drawChickens);
    }

    class Egg {
      constructor(x, y, dy) { this.x = x; this.y = y; this.dy = dy; }
      draw() { ctx.beginPath(); ctx.ellipse(this.x, this.y, 8, 12, 0, 0, Math.PI * 2); ctx.fillStyle = '#fff'; ctx.fill(); ctx.strokeStyle = '#ddd'; ctx.stroke(); }
      update() { this.y += this.dy * (slowTimer > 0 ? 0.5 : 1); }
    }

    class GoldenEgg extends Egg {
      draw() { ctx.beginPath(); ctx.ellipse(this.x, this.y, 10, 14, 0, 0, Math.PI * 2); ctx.fillStyle = 'gold'; ctx.fill(); ctx.strokeStyle = '#b8860b'; ctx.lineWidth = 2; ctx.stroke(); ctx.beginPath(); ctx.moveTo(this.x - 5, this.y - 5); ctx.lineTo(this.x, this.y - 10); ctx.lineTo(this.x + 5, this.y - 5); ctx.strokeStyle = '#fff8dc'; ctx.lineWidth = 1; ctx.stroke(); }
    }

    class Heart {
      constructor(x, y) { this.x = x; this.y = y; this.dy = 2; }
      update() { this.y += this.dy; }
      draw() {
        ctx.save();
        ctx.fillStyle = '#ff4d6d';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.bezierCurveTo(this.x - 12, this.y - 12, this.x - 18, this.y + 8, this.x, this.y + 20);
        ctx.bezierCurveTo(this.x + 18, this.y + 8, this.x + 12, this.y - 12, this.x, this.y);
        ctx.fill();
        ctx.restore();
      }
    }

    class Hourglass {
      constructor(x, y) { this.x = x; this.y = y; this.dy = 2.2; }
      update() { this.y += this.dy; }
      draw() {
        ctx.save();
        ctx.strokeStyle = '#87cefa';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.x - 10, this.y - 12);
        ctx.lineTo(this.x + 10, this.y - 12);
        ctx.lineTo(this.x - 10, this.y + 12);
        ctx.lineTo(this.x + 10, this.y + 12);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(this.x - 10, this.y - 12);
        ctx.lineTo(this.x + 10, this.y + 12);
        ctx.moveTo(this.x + 10, this.y - 12);
        ctx.lineTo(this.x - 10, this.y + 12);
        ctx.stroke();
        ctx.restore();
      }
    }

    class BigBasketPower {
      constructor(x, y) { this.x = x; this.y = y; this.dy = 2.4; }
      update() { this.y += this.dy; }
      draw() {
        ctx.save();
        ctx.fillStyle = '#ffa500';
        ctx.fillRect(this.x - 14, this.y - 10, 28, 20);
        ctx.fillStyle = '#fff8dc';
        ctx.fillRect(this.x - 10, this.y - 6, 20, 12);
        ctx.restore();
      }
    }

    class FloatingText { constructor(x, y, text, color) { this.x = x; this.y = y; this.text = text; this.color = color; this.opacity = 1; } update() { this.y -= 1; this.opacity -= 0.02; } draw() { ctx.globalAlpha = this.opacity; ctx.fillStyle = this.color; ctx.font = 'bold 16px Arial'; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1; } }

    function maybeSpawnPowerup(x) {
      if (Math.random() > powerupChance) return;
      const roll = Math.random();
      if (roll < 0.34) hearts.push(new Heart(x, 100));
      else if (roll < 0.67) hourglasses.push(new Hourglass(x, 100));
      else bigBaskets.push(new BigBasketPower(x, 100));
    }

    function resetGame() {
      score = 0; lives = 3; level = 1; nextLevelScore = 50;
      basketX = canvas.width / 2 - 40; basketWidth = baseBasketWidth; basketHeight = 35; speed = 12;
      eggs = []; goldenEggs = []; texts = []; hearts = []; hourglasses = []; bigBaskets = [];
      slowTimer = 0; bigTimer = 0;
      setupChickens();
      scoreDisplay.textContent = 'Punkty: 0';
      livesDisplay.textContent = '≈ªycia: 3';
      levelDisplay.textContent = 'Poziom: 1';
      gameRunning = true;
      drawChickens();
      gameLoop();
    }

    function drawBasket() { ctx.fillStyle = '#d2b48c'; ctx.fillRect(basketX, canvas.height - basketHeight - 10, basketWidth, basketHeight); ctx.strokeStyle = '#8b5a2b'; ctx.lineWidth = 3; ctx.strokeRect(basketX, canvas.height - basketHeight - 10, basketWidth, basketHeight); }

    function updateBasket() { if (keys.left) basketX -= speed; if (keys.right) basketX += speed; basketX = Math.max(0, Math.min(canvas.width - basketWidth, basketX)); }
    function addText(x, y, text, color) { texts.push(new FloatingText(x, y, text, color)); }

    function checkCollisions() {
      const basketY = canvas.height - basketHeight - 10;
      [...eggs, ...goldenEggs].forEach(obj => {
        if (obj.y > basketY && obj.x > basketX && obj.x < basketX + basketWidth) {
          if (obj instanceof GoldenEgg) {
            score += 100;
            addText(obj.x, basketY, '+100', '#ffd700');
          } else {
            score += 1;
            addText(obj.x, basketY, '+1', '#fff');
          }
          removeObject(obj);
          checkLevelProgress();
        }
      });
      checkPowerupCollisions(basketY);
    }

    function checkMissedEggs() {
      for (let i = eggs.length - 1; i >= 0; i--) {
        const e = eggs[i];
        if (e.y > canvas.height) { eggs.splice(i, 1); lives--; addText(e.x, canvas.height - 20, '-1 ≈ºycie', '#ff0000'); if (lives <= 0) endGame(); }
      }
      for (let i = goldenEggs.length - 1; i >= 0; i--) {
        if (goldenEggs[i].y > canvas.height) { goldenEggs.splice(i, 1); }
      }
      [hearts, hourglasses, bigBaskets].forEach(arr => {
        for (let i = arr.length - 1; i >= 0; i--) {
          if (arr[i].y > canvas.height) arr.splice(i, 1);
        }
      });
    }

    function removeObject(obj) { eggs = eggs.filter(e => e !== obj); goldenEggs = goldenEggs.filter(e => e !== obj); }

    function removePowerup(obj) {
      hearts = hearts.filter(p => p !== obj);
      hourglasses = hourglasses.filter(p => p !== obj);
      bigBaskets = bigBaskets.filter(p => p !== obj);
    }

    function checkPowerupCollisions(basketY) {
      const powerupHandler = (obj, onCatch) => {
        if (obj.y > basketY && obj.x > basketX && obj.x < basketX + basketWidth) {
          onCatch();
          removePowerup(obj);
        }
      };

      hearts.slice().forEach(heart => {
        powerupHandler(heart, () => {
          lives = Math.min(5, lives + 1);
          addText(heart.x, basketY, '+1 ≈ºycie', '#ff4d6d');
        });
      });

      hourglasses.slice().forEach(hourglass => {
        powerupHandler(hourglass, () => {
          slowTimer = 600;
          addText(hourglass.x, basketY, 'Spowolnienie!', '#87cefa');
        });
      });

      bigBaskets.slice().forEach(power => {
        powerupHandler(power, () => {
          bigTimer = 600;
          basketWidth = poweredBasketWidth;
          addText(power.x, basketY, 'Wiƒôkszy koszyk!', '#ffa500');
        });
      });
    }

    function checkLevelProgress() {
      let leveledUp = false;
      while (score >= nextLevelScore) {
        level++;
        nextLevelScore += 50;
        leveledUp = true;
      }
      if (leveledUp) {
        levelDisplay.textContent = `Poziom: ${level}`;
        setupChickens();
      }
    }

    function endGame() { gameRunning = false; finalScore.textContent = score; gameOverScreen.style.display = 'block'; }

    function gameLoop() {
      if (!gameRunning) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBasket();
      [...eggs, ...goldenEggs].forEach(o => { o.update(); o.draw(); });
      hearts.forEach(h => { h.update(); h.draw(); });
      hourglasses.forEach(h => { h.update(); h.draw(); });
      bigBaskets.forEach(b => { b.update(); b.draw(); });
      if (slowTimer > 0) slowTimer--;
      if (bigTimer > 0) {
        bigTimer--;
        if (bigTimer === 0) basketWidth = baseBasketWidth;
      }
      checkCollisions(); checkMissedEggs(); updateBasket();
      texts.forEach(t => { t.update(); t.draw(); }); texts = texts.filter(t => t.opacity > 0);
      scoreDisplay.textContent = `Punkty: ${score}`; livesDisplay.textContent = `≈ªycia: ${lives}`;
      requestAnimationFrame(gameLoop);
    }

    document.getElementById('startBtn').onclick = () => { startScreen.style.display = 'none'; resetGame(); };
    document.getElementById('restartBtn').onclick = () => { gameOverScreen.style.display = 'none'; resetGame(); };

    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') keys.left = true;
      if (e.key === 'ArrowRight') keys.right = true;
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft') keys.left = false;
      if (e.key === 'ArrowRight') keys.right = false;
    });

    function activateButton(id, key) {
      const btn = document.getElementById(id);
      ['touchstart', 'mousedown'].forEach(ev => btn.addEventListener(ev, e => { e.preventDefault(); keys[key] = true; }));
      ['touchend', 'mouseup', 'mouseleave'].forEach(ev => btn.addEventListener(ev, e => { e.preventDefault(); keys[key] = false; }));
    }

    activateButton('leftBtn', 'left');
    activateButton('rightBtn', 'right');
  </script>
</body>
</html>
