<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jajeczny Milioner ‚Äì LatajƒÖce Kurki Edition</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at top, #fdf6e3, #cbb48d);
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: "Comic Sans MS", cursive;
      height: 100vh;
      overflow: hidden;
      color: #333;
    }
    #gameContainer {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #gameCanvas {
      background: url('https://serwer2007468.home.pl/jajeczny/4381319.jpg') center/cover;
      border: 3px solid #333;
      border-radius: 1rem;
      box-shadow: inset 0 -3vw 3vw rgba(0, 0, 0, 0.3);
      aspect-ratio: 16 / 9;
      width: 90vw;
      max-width: 1000px;
      height: auto;
      display: block;
    }
    #chickensCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 5;
    }
    #hud {
      display: flex;
      justify-content: space-around;
      align-items: center;
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      font-size: 1.2rem;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 10;
    }
    #controls {
      display: flex;
      justify-content: space-between;
      width: 90%;
      max-width: 1000px;
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
    }
    .ctrl-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: none;
    }
    #startScreen, #gameOverScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 30px;
      border-radius: 12px;
      text-align: center;
      z-index: 20;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      margin-top: 15px;
    }
    button:hover { background: #45a049; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="level">Poziom: 1</div>
    <div id="score">Punkty: 0</div>
    <div id="lives">≈ªycia: 3</div>
  </div>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="960" height="540"></canvas>
    <canvas id="chickensCanvas" width="960" height="100"></canvas>
    <div id="controls">
      <div class="ctrl-btn" id="leftBtn">‚óÑ</div>
      <div class="ctrl-btn" id="rightBtn">‚ñ∫</div>
    </div>
  </div>
  <div id="startScreen">
    <h2>üê£ Jajeczny Milioner ü•ö</h2>
    <p>Z≈Çap jak najwiƒôcej jajek, unikajƒÖc ich upuszczenia!</p>
    <button id="startBtn">Start</button>
  </div>
  <div id="gameOverScreen" style="display:none">
    <h2>Koniec gry!</h2>
    <p>Tw√≥j wynik: <span id="finalScore"></span></p>
    <button id="restartBtn">Zagraj ponownie</button>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const chickenCanvas = document.getElementById('chickensCanvas');
    const cctx = chickenCanvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level');
    const livesDisplay = document.getElementById('lives');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScore = document.getElementById('finalScore');

    let score = 0, lives = 3, level = 1;
    let basketX, basketWidth, basketHeight, speed;
    let eggs = [], hearts = [], goldenEggs = [], hourglasses = [], bigBaskets = [];
    let texts = [], chickens = [];
    let keys = { left: false, right: false };
    let gameRunning = false;
    let gameLoopId = null;
    let chickenLoopId = null;
    const baseChickenCount = 2;
    const spawnChanceBase = 0.0012;
    const spawnChanceGrowth = 0.0003;
    const goldenEggChance = 0.12;
    let nextLevelScore = 50;
    let slowTimer = 0, bigTimer = 0;

    class Chicken {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = Math.random() * Math.PI * 2;
        this.direction = Math.random() < 0.5 ? 1 : -1;
      }
      update() {
        this.angle += 0.02;
        this.x += 1.2 * this.direction;
        this.y = 40 + Math.sin(this.angle) * 10;
        if (this.x < 50 || this.x > canvas.width - 50) this.direction *= -1;
        if (Math.random() < getCurrentSpawnChance()) spawnEggFromChicken(this.x);
      }
      draw() {
        cctx.beginPath();
        cctx.ellipse(this.x, this.y, 20, 15, 0, 0, Math.PI * 2);
        cctx.fillStyle = '#fff';
        cctx.fill();
        cctx.strokeStyle = '#aaa';
        cctx.stroke();
        cctx.beginPath();
        cctx.arc(this.x + 18 * this.direction, this.y - 5, 8, 0, Math.PI * 2);
        cctx.fillStyle = '#fff';
        cctx.fill();
        cctx.fillStyle = 'orange';
        cctx.beginPath();
        cctx.moveTo(this.x + 25 * this.direction, this.y - 5);
        cctx.lineTo(this.x + 35 * this.direction, this.y);
        cctx.lineTo(this.x + 25 * this.direction, this.y + 2);
        cctx.fill();
        cctx.fillStyle = 'red';
        cctx.beginPath();
        cctx.arc(this.x + 14 * this.direction, this.y - 14, 4, 0, Math.PI * 2);
        cctx.arc(this.x + 18 * this.direction, this.y - 16, 4, 0, Math.PI * 2);
        cctx.arc(this.x + 22 * this.direction, this.y - 14, 4, 0, Math.PI * 2);
        cctx.fill();
      }
    }

    function getCurrentSpawnChance() {
      return Math.min(0.01, spawnChanceBase + (level - 1) * spawnChanceGrowth);
    }

    function getChickenCountForLevel() {
      return baseChickenCount + (level - 1);
    }

    function spawnEggFromChicken(x) {
      const dy = 2 + Math.random();
      if (Math.random() < goldenEggChance) goldenEggs.push(new GoldenEgg(x, 100, dy));
      else eggs.push(new Egg(x, 100, dy));
    }

    function setupChickens() {
      const count = getChickenCountForLevel();
      const spacing = canvas.width / (count + 1);
      chickens = [];
      for (let i = 0; i < count; i++) {
        chickens.push(new Chicken(spacing * (i + 1), 40));
      }
    }

    function runChickens() {
      cctx.clearRect(0, 0, chickenCanvas.width, chickenCanvas.height);
      chickens.forEach(ch => { ch.update(); ch.draw(); });
      chickenLoopId = requestAnimationFrame(runChickens);
    }

    function startChickenLoop() {
      stopChickenLoop();
      runChickens();
    }

    function stopChickenLoop() {
      if (chickenLoopId !== null) {
        cancelAnimationFrame(chickenLoopId);
        chickenLoopId = null;
      }
    }

    class Egg {
      constructor(x, y, dy) { this.x = x; this.y = y; this.dy = dy; }
      draw() { ctx.beginPath(); ctx.ellipse(this.x, this.y, 8, 12, 0, 0, Math.PI * 2); ctx.fillStyle = '#fff'; ctx.fill(); ctx.strokeStyle = '#ddd'; ctx.stroke(); }
      update() { this.y += this.dy; }
    }

    class GoldenEgg extends Egg {
      draw() { ctx.beginPath(); ctx.ellipse(this.x, this.y, 10, 14, 0, 0, Math.PI * 2); ctx.fillStyle = 'gold'; ctx.fill(); ctx.strokeStyle = '#b8860b'; ctx.lineWidth = 2; ctx.stroke(); ctx.beginPath(); ctx.moveTo(this.x - 5, this.y - 5); ctx.lineTo(this.x, this.y - 10); ctx.lineTo(this.x + 5, this.y - 5); ctx.strokeStyle = '#fff8dc'; ctx.lineWidth = 1; ctx.stroke(); }
    }

    class FloatingText { constructor(x, y, text, color) { this.x = x; this.y = y; this.text = text; this.color = color; this.opacity = 1; } update() { this.y -= 1; this.opacity -= 0.02; } draw() { ctx.globalAlpha = this.opacity; ctx.fillStyle = this.color; ctx.font = 'bold 16px Arial'; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1; } }

    function resetGame() {
      stopGameLoop();
      stopChickenLoop();
      score = 0; lives = 3; level = 1; nextLevelScore = 50;
      basketX = canvas.width / 2 - 45; basketWidth = 120; basketHeight = 40; speed = 6;
      eggs = []; goldenEggs = []; texts = [];
      setupChickens();
      scoreDisplay.textContent = 'Punkty: 0';
      livesDisplay.textContent = '≈ªycia: 3';
      levelDisplay.textContent = 'Poziom: 1';
      gameRunning = true;
      startChickenLoop();
      gameLoop();
    }

    function drawBasket() {
      const basketY = canvas.height - basketHeight - 10;
      const left = basketX;
      const right = basketX + basketWidth;
      const gradient = ctx.createLinearGradient(0, basketY, 0, basketY + basketHeight);
      gradient.addColorStop(0, '#f4d7a6');
      gradient.addColorStop(1, '#c79253');

      ctx.save();
      ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetY = 4;
      ctx.beginPath();
      ctx.moveTo(left + 16, basketY);
      ctx.quadraticCurveTo(left, basketY + basketHeight * 0.4, left + 22, basketY + basketHeight);
      ctx.lineTo(right - 22, basketY + basketHeight);
      ctx.quadraticCurveTo(right, basketY + basketHeight * 0.4, right - 16, basketY);
      ctx.closePath();
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#8b5a2b';
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(left + 24, basketY + 6);
      ctx.quadraticCurveTo((left + right) / 2, basketY - 2, right - 24, basketY + 6);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = 'rgba(139, 90, 43, 0.6)';
      ctx.lineWidth = 2;
      const weaveCount = 4;
      for (let i = 1; i < weaveCount; i++) {
        const y = basketY + (basketHeight / weaveCount) * i;
        ctx.beginPath();
        ctx.moveTo(left + 26, y);
        ctx.lineTo(right - 26, y);
        ctx.stroke();
      }
      for (let i = 1; i < weaveCount; i++) {
        const x = left + (basketWidth / weaveCount) * i;
        ctx.beginPath();
        ctx.moveTo(x, basketY + 10);
        ctx.lineTo(x - 10, basketY + basketHeight - 6);
        ctx.stroke();
      }
      ctx.restore();

      ctx.save();
      ctx.lineWidth = 6;
      const handleGradient = ctx.createLinearGradient(basketX, basketY, basketX + basketWidth, basketY);
      handleGradient.addColorStop(0, '#a06b32');
      handleGradient.addColorStop(1, '#c98b4f');
      ctx.strokeStyle = handleGradient;
      ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetY = 2;
      ctx.beginPath();
      ctx.arc(basketX + basketWidth / 2, basketY + 2, basketWidth / 2.2, Math.PI, 0);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
      ctx.arc(basketX + basketWidth / 2, basketY + 2, basketWidth / 2.4, Math.PI, 0);
      ctx.stroke();
      ctx.restore();
    }

    function updateBasket() { if (keys.left) basketX -= speed; if (keys.right) basketX += speed; basketX = Math.max(0, Math.min(canvas.width - basketWidth, basketX)); }
    function addText(x, y, text, color) { texts.push(new FloatingText(x, y, text, color)); }

    function checkCollisions() {
      const basketY = canvas.height - basketHeight - 10;
      [...eggs, ...goldenEggs].forEach(obj => {
        if (obj.y > basketY && obj.x > basketX && obj.x < basketX + basketWidth) {
          if (obj instanceof Egg) { score += 1; addText(obj.x, basketY, '+1', '#fff'); }
          else if (obj instanceof GoldenEgg) { score += 100; addText(obj.x, basketY, '+100', '#ffd700'); }
          removeObject(obj);
          checkLevelProgress();
        }
      });
    }

    function checkMissedEggs() {
      for (let i = eggs.length - 1; i >= 0; i--) {
        const e = eggs[i];
        if (e.y > canvas.height) { eggs.splice(i, 1); lives--; addText(e.x, canvas.height - 20, '-1 ≈ºycie', '#ff0000'); if (lives <= 0) endGame(); }
      }
      for (let i = goldenEggs.length - 1; i >= 0; i--) {
        if (goldenEggs[i].y > canvas.height) { goldenEggs.splice(i, 1); }
      }
    }

    function removeObject(obj) { eggs = eggs.filter(e => e !== obj); goldenEggs = goldenEggs.filter(e => e !== obj); }

    function checkLevelProgress() {
      let leveledUp = false;
      while (score >= nextLevelScore) {
        level++;
        nextLevelScore += 50;
        leveledUp = true;
      }
      if (leveledUp) {
        levelDisplay.textContent = `Poziom: ${level}`;
        setupChickens();
      }
    }

    function endGame() {
      gameRunning = false;
      finalScore.textContent = score;
      gameOverScreen.style.display = 'block';
      stopGameLoop();
      stopChickenLoop();
    }

    function gameLoop() {
      if (!gameRunning) {
        stopGameLoop();
        return;
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBasket();
      [...eggs, ...goldenEggs].forEach(o => { o.update(); o.draw(); });
      checkCollisions(); checkMissedEggs(); updateBasket();
      texts.forEach(t => { t.update(); t.draw(); }); texts = texts.filter(t => t.opacity > 0);
      scoreDisplay.textContent = `Punkty: ${score}`; livesDisplay.textContent = `≈ªycia: ${lives}`;
      gameLoopId = requestAnimationFrame(gameLoop);
    }

    function stopGameLoop() {
      if (gameLoopId !== null) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
      }
    }

    document.getElementById('startBtn').onclick = () => { startScreen.style.display = 'none'; resetGame(); };
    document.getElementById('restartBtn').onclick = () => { gameOverScreen.style.display = 'none'; resetGame(); };

    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') keys.left = true;
      if (e.key === 'ArrowRight') keys.right = true;
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft') keys.left = false;
      if (e.key === 'ArrowRight') keys.right = false;
    });

    function activateButton(id, key) {
      const btn = document.getElementById(id);
      ['touchstart', 'mousedown'].forEach(ev => btn.addEventListener(ev, e => { e.preventDefault(); keys[key] = true; }));
      ['touchend', 'mouseup', 'mouseleave'].forEach(ev => btn.addEventListener(ev, e => { e.preventDefault(); keys[key] = false; }));
    }

    activateButton('leftBtn', 'left');
    activateButton('rightBtn', 'right');
  </script>
</body>
</html>
