<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jajeczny Milioner ‚Äì LatajƒÖce Kurki Edition</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at top, #fdf6e3, #cbb48d);
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: "Comic Sans MS", cursive;
      height: 100vh;
      overflow: hidden;
      color: #333;
    }
    #gameContainer {
      margin: 10em 0;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
    }
    #gameCanvas {
      background: transparent;
      border: 3px solid #333;
      border-radius: 1rem;
      box-shadow: inset 0 -3vw 3vw rgba(0, 0, 0, 0.3);
      aspect-ratio: 16 / 9;
      width: 90vw;
      max-width: 1000px;
      height: auto;
      display: block;
      position: relative;
      z-index: 2;
    }
    #backgroundLayer {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 140%;
      height: 140%;
      background: url('https://serwer2007468.home.pl/jajeczny/4381319.jpg') center/cover;
      filter: saturate(0.95) brightness(1.05);
      transform: translate(-50%, -50%);
      transition: transform 0.18s ease-out;
      pointer-events: none;
      z-index: 1;
    }
    #chickensCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 190px;
      pointer-events: none;
      z-index: 5;
    }
    #hud {
      display: flex;
      justify-content: space-around;
      align-items: center;
      width: 100%;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      font-size: 1.2rem;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 10;
    }
    #controls {
      display: flex;
      justify-content: space-between;
      width: 90%;
      max-width: 1000px;
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
    }
    .ctrl-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(0,0,0,0.6);
      color: white;
      font-size: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: none;
    }
    #startScreen, #gameOverScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 30px;
      border-radius: 12px;
      text-align: center;
      z-index: 20;
    }
    button { 
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      margin-top: 15px;
    }
    button:hover { background: #45a049; }
    #levelUpBanner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.92);
      background: rgba(0, 0, 0, 0.8);
      color: #fff7d6;
      padding: 24px 48px;
      border-radius: 14px;
      font-size: clamp(2rem, 4vw, 3rem);
      font-weight: bold;
      letter-spacing: 1px;
      text-shadow: 0 6px 12px rgba(0, 0, 0, 0.45);
      opacity: 0;
      pointer-events: none;
      z-index: 30;
      transition: opacity 0.35s ease, transform 0.35s ease;
    }
    #levelUpBanner.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
  </style>
</head>
<body>
  <div id="hud">
    <div id="level">Poziom: 1</div>
    <div id="score">Punkty: 0</div>
    <div id="lives">≈ªycia: 3</div>
  </div>
  <div id="gameContainer">
    <div id="backgroundLayer"></div>
    <canvas id="gameCanvas" width="960" height="540"></canvas>
    <canvas id="chickensCanvas" width="960" height="190"></canvas>
    <div id="levelUpBanner">Poziom 1</div>
    <div id="controls">
      <div class="ctrl-btn" id="leftBtn">‚óÑ</div>
      <div class="ctrl-btn" id="rightBtn">‚ñ∫</div>
    </div>
  </div>
  <div id="startScreen">
    <h2>üê£ Jajeczny Milioner ü•ö</h2>
    <p>Z≈Çap jak najwiƒôcej jajek, unikajƒÖc ich upuszczenia!</p>
    <button id="startBtn">Start</button>
  </div>
  <div id="gameOverScreen" style="display:none">
    <h2>Koniec gry!</h2>
    <p>Tw√≥j wynik: <span id="finalScore"></span></p>
    <button id="restartBtn">Zagraj ponownie</button>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const chickenCanvas = document.getElementById('chickensCanvas');
    const cctx = chickenCanvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const levelDisplay = document.getElementById('level');
    const livesDisplay = document.getElementById('lives');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScore = document.getElementById('finalScore');
    const backgroundLayer = document.getElementById('backgroundLayer');
    const levelUpBanner = document.getElementById('levelUpBanner');

    let score = 0, lives = 3, level = 1;
    let basketX, basketWidth, basketHeight, speed;
    let eggs = [], hearts = [], goldenEggs = [], hourglasses = [], bigBaskets = [];
    let texts = [], chickens = [];
    let keys = { left: false, right: false };
    let gameRunning = false;
    let gameLoopId = null;
    let chickenLoopId = null;
    const baseChickenCount = 2;
    const spawnChanceBase = 0.0045;
    const spawnChanceGrowth = 0.0004;
    const goldenEggChance = 0.12;
    const heartChance = 0.025;
    const hourglassChance = 0.018;
    const bigBasketChance = 0.018;
    const baseBasketWidth = 108;
    const poweredBasketWidth = 168;
    let nextLevelScore = 250;
    let slowTimer = 0, bigTimer = 0;
    let eggSpeedMultiplier = 1;
    let runner = null;
    let backgroundShiftX = 0, backgroundShiftY = 0;
    let levelBannerTimeout = null;

    class Chicken {
      constructor(x, y) {
        this.x = x;
        this.baseY = y + (Math.random() * 30 - 15);
        this.y = this.baseY;
        this.direction = Math.random() < 0.5 ? 1 : -1;
        this.speed = this.direction * (0.7 + Math.random() * 1.3);
        this.speedTarget = this.speed;
        this.speedTimer = 0;
        this.speedInterval = 80 + Math.random() * 160;
        this.verticalPhase = Math.random() * Math.PI * 2;
        this.verticalSpeed = 0.012 + Math.random() * 0.02;
        this.verticalAmplitude = 8 + Math.random() * 14;
        this.baseYTarget = this.baseY;
        this.flapPhase = Math.random() * Math.PI * 2;
        this.flapSpeed = 0.16 + Math.random() * 0.12;
        this.waddlePhase = Math.random() * Math.PI * 2;
        this.prepProgress = 0;
        this.layAnimation = 0;
        this.prepWindow = 60 + Math.random() * 20;
        this.preDropCue = 0;
        this.preDropPulse = Math.random() * Math.PI * 2;
        this.cueWindow = 60;
        this.dropTimer = this.randomDropInterval();
      }
      randomDropInterval() {
        const chance = getCurrentSpawnChance();
        const expected = Math.max(this.prepWindow + 35, 1 / Math.max(0.0001, chance));
        const variance = expected * 0.45;
        return Math.max(this.prepWindow + 25, expected + (Math.random() * 2 - 1) * variance);
      }
      update() {
        this.speedTimer += 1;
        if (this.speedTimer >= this.speedInterval) {
          this.speedTimer = 0;
          this.speedInterval = 80 + Math.random() * 160;
          this.speedTarget = this.direction * (0.6 + Math.random() * 1.6);
        }
        if (Math.random() < 0.004) {
          this.baseYTarget = 30 + Math.random() * 100;
        }
        this.speed += (this.speedTarget - this.speed) * 0.04;
        this.baseY += (this.baseYTarget - this.baseY) * 0.03;
        this.verticalPhase += this.verticalSpeed;
        const oscillation = Math.sin(this.verticalPhase) * this.verticalAmplitude;
        this.y = Math.max(24, Math.min(150, this.baseY + oscillation));
        this.x += this.speed;
        if (this.x < 50) {
          this.x = 50;
          this.direction = 1;
          this.speedTarget = this.direction * (0.6 + Math.random() * 1.6);
        } else if (this.x > canvas.width - 50) {
          this.x = canvas.width - 50;
          this.direction = -1;
          this.speedTarget = this.direction * (0.6 + Math.random() * 1.6);
        }
        this.flapPhase += this.flapSpeed + Math.abs(this.speed) * 0.02;
        this.waddlePhase += 0.04 + Math.abs(this.speed) * 0.05;
        if (this.layAnimation > 0) this.layAnimation = Math.max(0, this.layAnimation - 0.08);
        if (this.dropTimer <= this.cueWindow) {
          const timeLeft = Math.max(0, this.dropTimer);
          const targetCue = 1 - timeLeft / this.cueWindow;
          this.preDropCue += (targetCue - this.preDropCue) * 0.25;
          this.preDropPulse += 0.35 + this.preDropCue * 0.45;
        } else {
          this.preDropCue *= 0.9;
          this.preDropPulse += 0.18;
        }
        this.preDropCue = Math.max(0, Math.min(1, this.preDropCue));
        this.dropTimer -= 1;
        if (this.dropTimer < this.prepWindow) {
          const ratio = Math.max(0, 1 - this.dropTimer / this.prepWindow);
          this.prepProgress = Math.min(1, ratio);
        } else {
          this.prepProgress = 0;
        }
        if (this.dropTimer <= 0) {
          const prepNow = this.prepProgress;
          const dropX = this.x + this.direction * (12 + prepNow * 12);
          const dropY = this.y + 26 - prepNow * 6;
          spawnEggFromChicken(dropX, dropY);
          this.dropTimer = this.randomDropInterval();
          this.layAnimation = 1;
          this.prepProgress = 0;
          this.preDropCue = 0;
        }
      }
      draw() {
        const lean = this.speed * 0.05;
        const bob = Math.sin(this.waddlePhase) * (2.5 + Math.abs(this.speed) * 0.6);
        const warningShake = Math.sin(this.preDropPulse) * this.preDropCue * 3;
        const prepSquash = this.prepProgress * 0.25 + this.preDropCue * 0.15;
        const squat = this.prepProgress * 5 + this.preDropCue * 8 - this.layAnimation * 3;
        const wingLift = Math.sin(this.flapPhase) * (0.35 + Math.abs(this.speed) * 0.1)
          + this.layAnimation * 0.6
          - this.prepProgress * 0.4
          + this.preDropCue * 1.1;
        const headNod = Math.sin(this.waddlePhase * 1.5) * 2 - this.prepProgress * 3 - this.preDropCue * 6 + warningShake * 0.4;
        const tailFan = 0.4 + this.prepProgress * 0.6 + this.layAnimation * 0.4 + this.preDropCue * 0.5;
        const legSwing = Math.sin(this.waddlePhase) * (6 + Math.abs(this.speed) * 3) + warningShake * 0.6;
        const bodyRotation = lean * 0.3 - this.prepProgress * 0.1 + this.preDropCue * 0.35;
        cctx.save();
        cctx.translate(this.x, this.y + bob + squat + warningShake * 0.4);
        cctx.scale(this.direction, 1);
        
        // Shadow
        cctx.save();
        cctx.scale(1, 0.35);
        cctx.beginPath();
        cctx.ellipse(0, 70, 28, 12, 0, 0, Math.PI * 2);
        cctx.fillStyle = 'rgba(0,0,0,0.12)';
        cctx.fill();
        cctx.restore();

        cctx.rotate(bodyRotation);

        // Tail feathers
        cctx.save();
        cctx.translate(-22, -10);
        cctx.rotate(-tailFan);
        cctx.fillStyle = '#f0f0f5';
        for (let i = 0; i < 4; i++) {
          cctx.save();
          cctx.rotate(-i * 0.25);
          cctx.beginPath();
          cctx.moveTo(0, 0);
          cctx.quadraticCurveTo(-16, -6, -26, 12);
          cctx.quadraticCurveTo(-12, 10, 0, 18);
          cctx.closePath();
          cctx.fill();
          cctx.restore();
        }
        cctx.restore();

        // Body
        cctx.save();
        cctx.scale(1 + prepSquash * 0.4, 1 - prepSquash * 0.35);
        const bodyGradient = cctx.createLinearGradient(-10, -26, 34, 32);
        bodyGradient.addColorStop(0, '#fffdfa');
        bodyGradient.addColorStop(0.6, '#f1f1f6');
        bodyGradient.addColorStop(1, '#e6e8f0');
        cctx.fillStyle = bodyGradient;
        cctx.beginPath();
        cctx.ellipse(0, 0, 34, 24, 0.15, 0, Math.PI * 2);
        cctx.fill();
        cctx.restore();

        // Wing
        cctx.save();
        cctx.translate(2, -4 - this.prepProgress * 2 + this.layAnimation * 2);
        cctx.rotate(-wingLift);
        cctx.beginPath();
        cctx.moveTo(0, 0);
        cctx.quadraticCurveTo(22, -10, 26, 14);
        cctx.quadraticCurveTo(18, 16, 0, 12);
        cctx.closePath();
        cctx.fillStyle = '#f8f7fb';
        cctx.fill();
        cctx.strokeStyle = 'rgba(170,170,200,0.7)';
        cctx.lineWidth = 1.5;
        cctx.stroke();
        cctx.restore();

        // Belly highlight when preparing
        if (this.prepProgress > 0.05 || this.preDropCue > 0.05) {
          cctx.save();
          cctx.globalAlpha = 0.25 + this.prepProgress * 0.35 + this.preDropCue * 0.45;
          cctx.fillStyle = '#fff7d6';
          cctx.beginPath();
          cctx.ellipse(10, 6, 16, 12, 0, 0, Math.PI * 2);
          cctx.fill();
          cctx.restore();
        }

        // Legs
        cctx.save();
        cctx.translate(4, 22);
        cctx.strokeStyle = '#c26a17';
        cctx.lineWidth = 3;
        cctx.lineCap = 'round';
        const legOffset = Math.max(0.4, 0.9 - this.prepProgress * 0.5);
        cctx.beginPath();
        cctx.moveTo(-6, 0);
        cctx.lineTo(-6 + legSwing * 0.2, 14 * legOffset);
        cctx.moveTo(6, 0);
        cctx.lineTo(6 - legSwing * 0.2, 14 * legOffset);
        cctx.stroke();
        // Feet
        cctx.beginPath();
        cctx.moveTo(-10, 14 * legOffset);
        cctx.lineTo(-2, 14 * legOffset);
        cctx.moveTo(-6, 14 * legOffset);
        cctx.lineTo(-12, 18 * legOffset);
        cctx.moveTo(10, 14 * legOffset);
        cctx.lineTo(2, 14 * legOffset);
        cctx.moveTo(6, 14 * legOffset);
        cctx.lineTo(12, 18 * legOffset);
        cctx.stroke();
        cctx.restore();

        // Head
        cctx.save();
        cctx.translate(28 + this.preDropCue * 2, -16 + headNod - this.preDropCue * 4);
        cctx.rotate(lean * 0.25 - this.prepProgress * 0.05 + this.preDropCue * 0.15);
        const headGradient = cctx.createRadialGradient(-2, -6, 2, 0, 0, 16);
        headGradient.addColorStop(0, '#ffffff');
        headGradient.addColorStop(1, '#ececf4');
        cctx.fillStyle = headGradient;
        cctx.beginPath();
        cctx.ellipse(0, 0, 16, 14, 0, 0, Math.PI * 2);
        cctx.fill();

        // Eye
        cctx.beginPath();
        cctx.arc(4, -4, 2.6, 0, Math.PI * 2);
        cctx.fillStyle = '#1f1f1f';
        cctx.fill();
        cctx.beginPath();
        cctx.arc(3.5, -4.4, 1.2, 0, Math.PI * 2);
        cctx.fillStyle = '#fff';
        cctx.fill();

        // Beak
        cctx.beginPath();
        cctx.moveTo(12, -2);
        cctx.quadraticCurveTo(24 + this.prepProgress * 6, 2 + this.prepProgress * 4, 12, 6);
        cctx.closePath();
        cctx.fillStyle = '#f3a11a';
        cctx.fill();
        cctx.lineWidth = 1.2;
        cctx.strokeStyle = '#d47700';
        cctx.stroke();

        // Comb and wattle
        cctx.fillStyle = '#d13140';
        cctx.beginPath();
        cctx.moveTo(-2, -10 - this.preDropCue * 2);
        cctx.quadraticCurveTo(2, -18 - this.prepProgress * 2 - this.preDropCue * 3, 6, -10 - this.preDropCue * 1.5);
        cctx.quadraticCurveTo(10, -18 - this.prepProgress * 3 - this.preDropCue * 2, 14, -8 - this.preDropCue);
        cctx.quadraticCurveTo(16, -14 - this.prepProgress * 1.5 - this.preDropCue * 1.5, 18, -6);
        cctx.quadraticCurveTo(10, -4 - this.preDropCue * 0.8, 2, -6 - this.preDropCue * 0.6);
        cctx.closePath();
        cctx.fill();
        cctx.beginPath();
        cctx.ellipse(10, 4 + this.preDropCue * 2, 4, 6 + this.prepProgress * 3 + this.preDropCue * 2, 0, 0, Math.PI * 2);
        cctx.fill();

        cctx.restore(); // head

        cctx.restore(); // body transform
      }
    }

    function getCurrentSpawnChance() {
      return Math.min(0.01, spawnChanceBase + (level - 1) * spawnChanceGrowth);
    }

    function getChickenCountForLevel() {
      return baseChickenCount + (level - 1);
    }

    function spawnEggFromChicken(x, yStart) {
      const dy = 4 + Math.random() * 1.5 + level * 0.3;
      const startY = Math.max(60, Math.min(160, yStart));
      if (Math.random() < goldenEggChance) goldenEggs.push(new GoldenEgg(x, startY, dy));
      else eggs.push(new Egg(x, startY, dy));
      maybeSpawnPowerup(x, startY);
    }

    function maybeSpawnPowerup(x, yStart = 100) {
      const roll = Math.random();
      const baseY = Math.max(60, Math.min(160, yStart));
      const dy = 3 + Math.random() * 1.2 + level * 0.2;
      if (roll < heartChance) hearts.push(new Heart(x, baseY, dy));
      else if (roll < heartChance + hourglassChance) hourglasses.push(new Hourglass(x, baseY, dy));
      else if (roll < heartChance + hourglassChance + bigBasketChance) bigBaskets.push(new BigBasket(x, baseY, dy));
    }

    function setupChickens() {
      const count = getChickenCountForLevel();
      const spacing = canvas.width / (count + 1);
      chickens = [];
      for (let i = 0; i < count; i++) {
        chickens.push(new Chicken(spacing * (i + 1), 60 + Math.random() * 70));
      }
    }

    function runChickens() {
      cctx.clearRect(0, 0, chickenCanvas.width, chickenCanvas.height);
      chickens.forEach(ch => { ch.update(); ch.draw(); });
      chickenLoopId = requestAnimationFrame(runChickens);
    }

    function startChickenLoop() {
      stopChickenLoop();
      runChickens();
    }

    function stopChickenLoop() {
      if (chickenLoopId !== null) {
        cancelAnimationFrame(chickenLoopId);
        chickenLoopId = null;
      }
    }

    class Egg {
      constructor(x, y, dy) { this.x = x; this.y = y; this.dy = dy; }
      draw() { ctx.beginPath(); ctx.ellipse(this.x, this.y, 8, 12, 0, 0, Math.PI * 2); ctx.fillStyle = '#fff'; ctx.fill(); ctx.strokeStyle = '#ddd'; ctx.stroke(); }
      update() { this.y += this.dy * eggSpeedMultiplier; }
    }

    class GoldenEgg extends Egg {
      draw() { ctx.beginPath(); ctx.ellipse(this.x, this.y, 10, 14, 0, 0, Math.PI * 2); ctx.fillStyle = 'gold'; ctx.fill(); ctx.strokeStyle = '#b8860b'; ctx.lineWidth = 2; ctx.stroke(); ctx.beginPath(); ctx.moveTo(this.x - 5, this.y - 5); ctx.lineTo(this.x, this.y - 10); ctx.lineTo(this.x + 5, this.y - 5); ctx.strokeStyle = '#fff8dc'; ctx.lineWidth = 1; ctx.stroke(); }
    }

    class PowerUp {
      constructor(x, y, dy) { this.x = x; this.y = y; this.dy = dy; }
      update() { this.y += this.dy * eggSpeedMultiplier; }
    }

    class Heart extends PowerUp {
      draw() {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.bezierCurveTo(this.x - 12, this.y - 12, this.x - 14, this.y + 8, this.x, this.y + 14);
        ctx.bezierCurveTo(this.x + 14, this.y + 8, this.x + 12, this.y - 12, this.x, this.y);
        ctx.fillStyle = '#ff4b6b';
        ctx.fill();
        ctx.strokeStyle = '#ff9aad';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }
    }

    class Hourglass extends PowerUp {
      draw() {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(this.x - 10, this.y - 14);
        ctx.lineTo(this.x + 10, this.y - 14);
        ctx.lineTo(this.x + 6, this.y - 2);
        ctx.lineTo(this.x + 10, this.y + 14);
        ctx.lineTo(this.x - 10, this.y + 14);
        ctx.lineTo(this.x - 6, this.y - 2);
        ctx.closePath();
        ctx.fillStyle = '#66d9ff';
        ctx.fill();
        ctx.strokeStyle = '#0a5273';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(this.x - 6, this.y - 2);
        ctx.lineTo(this.x + 6, this.y - 2);
        ctx.strokeStyle = '#0a5273';
        ctx.stroke();
        ctx.restore();
      }
    }

    class BigBasket extends PowerUp {
      draw() {
        ctx.save();
        ctx.fillStyle = '#ffdd55';
        ctx.strokeStyle = '#aa7a00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.rect(this.x - 12, this.y - 8, 24, 16);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(this.x, this.y - 10, 12, Math.PI, 0);
        ctx.stroke();
        ctx.restore();
      }
    }

    class Runner {
      constructor() {
        this.facing = 1;
        this.runPhase = 0;
        this.moving = false;
        this.basketLean = 0;
        this.basketPress = 0;
        this.pushReach = 0;
        this.bodyLean = 0;
        this.holdRelative = null;
        this.pushRelative = null;
        this.basketPivot = null;
      }
      update(moveLeft, moveRight) {
        const moving = moveLeft !== moveRight && (moveLeft || moveRight);
        if (moving) {
          this.moving = true;
          this.facing = moveRight ? 1 : -1;
          this.runPhase = (this.runPhase + 0.24) % (Math.PI * 2);
        } else {
          this.moving = false;
          this.runPhase *= 0.82;
          if (Math.abs(this.runPhase) < 0.01) this.runPhase = 0;
        }
        const stridePulse = Math.sin(this.runPhase + Math.PI / 2);
        const leanTarget = moving ? this.facing * (0.16 + stridePulse * 0.04) : 0;
        const strideReach = Math.abs(Math.sin(this.runPhase)) * 6;
        const pressTarget = moving ? this.facing * 30 : 0;
        const reachTarget = moving ? 14 + Math.abs(Math.sin(this.runPhase)) * 8 : 0;
        const bodyLeanTarget = moving ? this.facing * 0.08 : 0;
        this.basketLean += (leanTarget - this.basketLean) * 0.2;
        this.basketPress += (pressTarget - this.basketPress) * 0.18;
        this.pushReach += (reachTarget - this.pushReach) * 0.22;
        this.bodyLean += (bodyLeanTarget - this.bodyLean) * 0.14;
        this.bodyLean = Math.max(-0.22, Math.min(0.22, this.bodyLean));
        this.basketPress = Math.max(-30, Math.min(30, this.basketPress));
        this.basketLean = Math.max(-0.28, Math.min(0.28, this.basketLean));
        this.pushReach = Math.max(0, Math.min(26, this.pushReach));
        if (!moving) {
          this.basketPress *= 0.9;
          if (Math.abs(this.basketPress) < 0.02) this.basketPress = 0;
          this.basketLean *= 0.82;
          this.pushReach *= 0.8;
          this.bodyLean *= 0.7;
        }
      }
      getBasketOffset() { return this.basketPress; }
      getBasketLean() { return this.basketLean; }
      setBasketPivot(pivotX, pivotY, lean) { this.basketPivot = { pivotX, pivotY, lean }; }
      draw() {
        const basketY = canvas.height - basketHeight - 10;
        const offsetX = this.basketPress;
        const centerX = basketX + basketWidth / 2 + offsetX;
        const runSwing = Math.sin(this.runPhase);
        const runLift = Math.cos(this.runPhase);
        const bob = this.moving ? Math.abs(runSwing) * 2 : 0;

        const gripInset = Math.max(24, basketWidth * 0.26);
        const holdLocal = basketWidth / 2 - gripInset;
        const pushLocal = holdLocal - 18 + this.pushReach * 0.35;
        const pushHeight = basketHeight * 0.55 + (this.moving ? Math.abs(runSwing) * 4 : 0);
        this.holdRelative = { x: holdLocal * this.facing, y: -basketHeight };
        this.pushRelative = { x: pushLocal * this.facing, y: pushHeight - basketHeight };
        if (!this.moving && this.pushReach < 1) this.pushRelative = null;

        ctx.save();
        ctx.translate(centerX, basketY);
        ctx.rotate(this.bodyLean + (this.moving ? runSwing * 0.02 * this.facing : 0));
        ctx.scale(this.facing, 1);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.strokeStyle = '#3f2e1f';
        ctx.lineWidth = 7;
        const backSwing = this.moving ? -runSwing : -0.18;
        ctx.beginPath();
        ctx.moveTo(-12, -8 - bob * 0.35);
        ctx.quadraticCurveTo(-26 - backSwing * 12, 14 + runLift * 5, -6, 46);
        ctx.stroke();
        ctx.strokeStyle = '#f6d2b3';
        ctx.lineWidth = 6;
        const pushSwing = this.moving ? Math.sin(this.runPhase + Math.PI / 2) : 0;
        ctx.beginPath();
        ctx.moveTo(-18, -50 - bob);
        ctx.quadraticCurveTo(-36 - pushSwing * 14, -22 + runLift * 3, pushLocal, pushHeight);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(16, -52 - bob * 0.8);
        ctx.quadraticCurveTo(30 + runSwing * 10, -20 - runLift * 3, holdLocal, 0);
        ctx.stroke();

        ctx.strokeStyle = '#3f2e1f';
        ctx.lineWidth = 7;
        ctx.beginPath();
        ctx.moveTo(10, -6 - bob * 0.2);
        ctx.quadraticCurveTo(24 + runSwing * 10, 12 - runLift * 6, 6, 44);
        ctx.stroke();

        ctx.fillStyle = '#242424';
        ctx.beginPath();
        ctx.ellipse(-6, 46, 10, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(6, 46, 10, 4, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#2b8cf7';
        ctx.fillRect(-16, -60 - bob, 32, 52);
        ctx.fillStyle = '#1f5fba';
        ctx.fillRect(-16, -34 - bob, 32, 9);

        ctx.fillStyle = '#f6d2b3';
        ctx.beginPath();
        ctx.arc(0, -76 - bob, 15, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#3b2a1a';
        ctx.beginPath();
        ctx.ellipse(0, -83 - bob, 17, 12, 0, Math.PI, 0);
        ctx.fill();
        ctx.fillRect(-17, -83 - bob, 34, 5);

        ctx.fillStyle = '#1b1b1b';
        ctx.beginPath();
        ctx.arc(-5, -78 - bob, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(5, -78 - bob, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#cc6f3f';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -72 - bob, 6, 0, Math.PI);
        ctx.stroke();

        ctx.restore();
      }
      drawHandsOverlay() {
        if (!this.basketPivot || !this.holdRelative) return;
        const { pivotX, pivotY, lean } = this.basketPivot;
        const cos = Math.cos(lean);
        const sin = Math.sin(lean);
        ctx.save();
        ctx.fillStyle = '#f6d2b3';
        const hold = this.holdRelative;
        const normalX = Math.sin(lean);
        const normalY = -Math.cos(lean);
        const rimLift = 5.5;
        const holdX = pivotX + hold.x * cos - hold.y * sin + normalX * rimLift;
        const holdY = pivotY + hold.x * sin + hold.y * cos + normalY * rimLift;
        ctx.beginPath();
        ctx.ellipse(holdX, holdY - 3, 5.5, 3.2, lean, 0, Math.PI * 2);
        ctx.fill();
        if (this.pushRelative) {
          const push = this.pushRelative;
          const pushX = pivotX + push.x * cos - push.y * sin + normalX * (rimLift - 0.8);
          const pushY = pivotY + push.x * sin + push.y * cos + normalY * (rimLift - 0.8);
          ctx.globalAlpha = this.moving ? 1 : 0.75;
          ctx.beginPath();
          ctx.ellipse(pushX, pushY - 2, 6.5, 3.6, lean, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }
    }

    class FloatingText { constructor(x, y, text, color) { this.x = x; this.y = y; this.text = text; this.color = color; this.opacity = 1; } update() { this.y -= 1; this.opacity -= 0.02; } draw() { ctx.globalAlpha = this.opacity; ctx.fillStyle = this.color; ctx.font = 'bold 16px Arial'; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1; } }

    function resetGame() {
      stopGameLoop();
      stopChickenLoop();
      score = 0; lives = 3; level = 1; nextLevelScore = 250;
      basketWidth = baseBasketWidth;
      basketX = canvas.width / 2 - basketWidth / 2;
      basketHeight = 36; speed = 12;
      eggs = []; goldenEggs = []; hearts = []; hourglasses = []; bigBaskets = []; texts = [];
      slowTimer = 0; bigTimer = 0; eggSpeedMultiplier = 0.5;
      runner = new Runner();
      setupChickens();
      scoreDisplay.textContent = 'Punkty: 0';
      livesDisplay.textContent = '≈ªycia: 3';
      levelDisplay.textContent = 'Poziom: 1';
      backgroundShiftX = 0;
      backgroundShiftY = 0;
      if (backgroundLayer) backgroundLayer.style.transform = 'translate(-50%, -50%)';
      if (levelUpBanner) {
        levelUpBanner.classList.remove('show');
        levelUpBanner.textContent = 'Poziom 1';
      }
      if (levelBannerTimeout) {
        clearTimeout(levelBannerTimeout);
        levelBannerTimeout = null;
      }
      gameRunning = true;
      startChickenLoop();
      gameLoop();
    }

    function drawBasket() {
      if (!runner) runner = new Runner();
      const offsetX = runner.getBasketOffset ? runner.getBasketOffset() : 0;
      const lean = runner.getBasketLean ? runner.getBasketLean() : 0;
      runner.draw();
      const basketY = canvas.height - basketHeight - 10;
      const left = basketX + offsetX;
      const right = left + basketWidth;
      const pivotX = left + basketWidth / 2;
      const pivotY = basketY + basketHeight;
      runner.setBasketPivot && runner.setBasketPivot(pivotX, pivotY, lean);

      ctx.save();
      ctx.translate(pivotX, pivotY);
      ctx.rotate(lean);
      ctx.translate(-pivotX, -pivotY);

      ctx.save();
      ctx.shadowColor = 'rgba(0, 0, 0, 0.25)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetY = 4;
      const gradient = ctx.createLinearGradient(left, basketY, left, basketY + basketHeight);
      gradient.addColorStop(0, '#f4d7a6');
      gradient.addColorStop(1, '#c79253');
      ctx.beginPath();
      ctx.moveTo(left + 16, basketY);
      ctx.quadraticCurveTo(left, basketY + basketHeight * 0.4, left + 22, basketY + basketHeight);
      ctx.lineTo(right - 22, basketY + basketHeight);
      ctx.quadraticCurveTo(right, basketY + basketHeight * 0.4, right - 16, basketY);
      ctx.closePath();
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#8b5a2b';
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(left + 24, basketY + 6);
      ctx.quadraticCurveTo((left + right) / 2, basketY - 4, right - 24, basketY + 6);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.32)';
      ctx.lineWidth = 1.8;
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = 'rgba(139, 90, 43, 0.6)';
      ctx.lineWidth = 2;
      const weaveCount = 4;
      for (let i = 1; i < weaveCount; i++) {
        const y = basketY + (basketHeight / weaveCount) * i;
        ctx.beginPath();
        ctx.moveTo(left + 26, y);
        ctx.lineTo(right - 26, y);
        ctx.stroke();
      }
      for (let i = 1; i < weaveCount; i++) {
        const x = left + (basketWidth / weaveCount) * i;
        ctx.beginPath();
        ctx.moveTo(x, basketY + 10);
        ctx.lineTo(x - 10, basketY + basketHeight - 6);
        ctx.stroke();
      }
      ctx.restore();

      ctx.save();
      ctx.lineWidth = 4.2;
      const handleGradient = ctx.createLinearGradient(left, basketY, right, basketY);
      handleGradient.addColorStop(0, '#a06b32');
      handleGradient.addColorStop(1, '#c98b4f');
      ctx.strokeStyle = handleGradient;
      ctx.shadowColor = 'rgba(0, 0, 0, 0.18)';
      ctx.shadowBlur = 3;
      ctx.shadowOffsetY = 1.5;
      ctx.beginPath();
      ctx.arc(left + basketWidth / 2, basketY + 4, basketWidth / 2.8, Math.PI, 0);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.beginPath();
      ctx.lineWidth = 1.6;
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
      ctx.arc(left + basketWidth / 2, basketY + 4, basketWidth / 3, Math.PI, 0);
      ctx.stroke();
      ctx.restore();

      ctx.restore();
      runner.drawHandsOverlay();
    }

    function updateBasket() {
      if (!runner) runner = new Runner();
      const movingLeft = keys.left && !keys.right;
      const movingRight = keys.right && !keys.left;
      if (movingLeft) basketX -= speed;
      if (movingRight) basketX += speed;
      runner.update(movingLeft, movingRight);
      const offsetX = runner.getBasketOffset ? runner.getBasketOffset() : 0;
      let visualLeft = basketX + offsetX;
      let visualRight = visualLeft + basketWidth;
      if (visualLeft < 0) {
        basketX -= visualLeft;
        visualLeft = 0;
        visualRight = basketWidth;
      }
      if (visualRight > canvas.width) {
        basketX -= (visualRight - canvas.width);
        visualRight = canvas.width;
        visualLeft = visualRight - basketWidth;
      }
      basketX = Math.max(Math.min(basketX, canvas.width - basketWidth), 0);
      applyBackgroundParallax();
    }

    function applyBackgroundParallax() {
      if (!backgroundLayer) return;
      const displayWidth = canvas.clientWidth || canvas.width;
      const displayHeight = canvas.clientHeight || canvas.height;
      const offsetX = runner && runner.getBasketOffset ? runner.getBasketOffset() : 0;
      const basketCenter = basketX + offsetX + basketWidth / 2;
      const normalizedCenter = canvas.width > 0 ? basketCenter / canvas.width : 0.5;
      const stridePhase = runner ? runner.runPhase : 0;
      const stridePresence = runner && runner.moving ? 1 : 0;
      const strideWaveX = Math.sin(stridePhase) * stridePresence;
      const strideWaveY = Math.cos(stridePhase) * stridePresence;
      const lateralRange = displayWidth * 0.035;
      const strideInfluenceX = -strideWaveX * displayWidth * 0.01;
      const targetShiftX = -(normalizedCenter - 0.5) * lateralRange + strideInfluenceX;
      const baseVerticalRange = displayHeight * 0.006;
      const hoverOffset = displayHeight * 0.003;
      const targetShiftY = -strideWaveY * baseVerticalRange - hoverOffset * stridePresence;
      backgroundShiftX += (targetShiftX - backgroundShiftX) * 0.025;
      backgroundShiftY += (targetShiftY - backgroundShiftY) * 0.035;
      backgroundLayer.style.transform = `translate(-50%, -50%) translate(${backgroundShiftX.toFixed(2)}px, ${backgroundShiftY.toFixed(2)}px)`;
    }
    function addText(x, y, text, color) { texts.push(new FloatingText(x, y, text, color)); }

    function checkCollisions() {
      const basketY = canvas.height - basketHeight - 10;
      const offsetX = runner && runner.getBasketOffset ? runner.getBasketOffset() : 0;
      const left = basketX + offsetX;
      const right = left + basketWidth;
      [...eggs, ...goldenEggs].forEach(obj => {
        if (obj.y > basketY && obj.x > left && obj.x < right) {
          if (obj instanceof GoldenEgg) { score += 100; addText(obj.x, basketY, '+100', '#ffd700'); }
          else if (obj instanceof Egg) { score += 10; addText(obj.x, basketY, '+10', '#fff'); }
          removeObject(obj);
          checkLevelProgress();
        }
      });
      for (let i = hearts.length - 1; i >= 0; i--) {
        const heart = hearts[i];
        if (heart.y > basketY && heart.x > left && heart.x < right) {
          lives = Math.min(lives + 1, 5);
          addText(heart.x, basketY, '+1 ≈ºycie', '#ff4b6b');
          hearts.splice(i, 1);
        }
      }
      for (let i = hourglasses.length - 1; i >= 0; i--) {
        const hourglass = hourglasses[i];
        if (hourglass.y > basketY && hourglass.x > left && hourglass.x < right) {
          slowTimer = 360;
          eggSpeedMultiplier = 0.55;
          addText(hourglass.x, basketY, 'Spowolnienie!', '#66d9ff');
          hourglasses.splice(i, 1);
        }
      }
      for (let i = bigBaskets.length - 1; i >= 0; i--) {
        const big = bigBaskets[i];
        if (big.y > basketY && big.x > left && big.x < right) {
          bigTimer = 360;
          const center = left + basketWidth / 2;
          basketWidth = poweredBasketWidth;
          const offsetAdjust = runner && runner.getBasketOffset ? runner.getBasketOffset() : 0;
          basketX = Math.max(0, Math.min(canvas.width - basketWidth, center - basketWidth / 2 - offsetAdjust));
          addText(big.x, basketY, 'Mega kosz!', '#ffdd55');
          bigBaskets.splice(i, 1);
        }
      }
    }

    function checkMissedEggs() {
      for (let i = eggs.length - 1; i >= 0; i--) {
        const e = eggs[i];
        if (e.y > canvas.height) { eggs.splice(i, 1); lives--; addText(e.x, canvas.height - 20, '-1 ≈ºycie', '#ff0000'); if (lives <= 0) endGame(); }
      }
      for (let i = goldenEggs.length - 1; i >= 0; i--) {
        if (goldenEggs[i].y > canvas.height) { goldenEggs.splice(i, 1); }
      }
      for (let i = hearts.length - 1; i >= 0; i--) {
        if (hearts[i].y > canvas.height) hearts.splice(i, 1);
      }
      for (let i = hourglasses.length - 1; i >= 0; i--) {
        if (hourglasses[i].y > canvas.height) hourglasses.splice(i, 1);
      }
      for (let i = bigBaskets.length - 1; i >= 0; i--) {
        if (bigBaskets[i].y > canvas.height) bigBaskets.splice(i, 1);
      }
    }

    function removeObject(obj) { eggs = eggs.filter(e => e !== obj); goldenEggs = goldenEggs.filter(e => e !== obj); }

    function checkLevelProgress() {
      let leveledUp = false;
      while (score >= nextLevelScore) {
        level++;
        nextLevelScore += 250;
        leveledUp = true;
      }
      if (leveledUp) {
        levelDisplay.textContent = `Poziom: ${level}`;
        setupChickens();
        showLevelUpBanner();
      }
    }

    function showLevelUpBanner() {
      if (!levelUpBanner) return;
      levelUpBanner.textContent = `Poziom ${level}`;
      levelUpBanner.classList.add('show');
      if (levelBannerTimeout) clearTimeout(levelBannerTimeout);
      levelBannerTimeout = setTimeout(() => {
        levelUpBanner.classList.remove('show');
        levelBannerTimeout = null;
      }, 2400);
    }

    function endGame() {
      gameRunning = false;
      finalScore.textContent = score;
      gameOverScreen.style.display = 'block';
      stopGameLoop();
      stopChickenLoop();
    }

    function gameLoop() {
      if (!gameRunning) {
        stopGameLoop();
        return;
      }
      updateBasket();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBasket();
      [...eggs, ...goldenEggs, ...hearts, ...hourglasses, ...bigBaskets].forEach(o => { o.update(); o.draw(); });
      checkCollisions(); checkMissedEggs();
      handlePowerupTimers();
      texts.forEach(t => { t.update(); t.draw(); }); texts = texts.filter(t => t.opacity > 0);
      scoreDisplay.textContent = `Punkty: ${score}`; livesDisplay.textContent = `≈ªycia: ${lives}`;
      gameLoopId = requestAnimationFrame(gameLoop);
    }

    function handlePowerupTimers() {
      if (slowTimer > 0) {
        slowTimer--;
        if (slowTimer === 0) eggSpeedMultiplier = 1;
      }
      if (bigTimer > 0) {
        bigTimer--;
        if (bigTimer === 0) {
          const offsetAdjust = runner && runner.getBasketOffset ? runner.getBasketOffset() : 0;
          const basketCenter = basketX + offsetAdjust + basketWidth / 2;
          basketWidth = baseBasketWidth;
          basketX = Math.max(0, Math.min(canvas.width - basketWidth, basketCenter - basketWidth / 2 - offsetAdjust));
        }
      }
    }

    function stopGameLoop() {
      if (gameLoopId !== null) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
      }
    }

    document.getElementById('startBtn').onclick = () => { startScreen.style.display = 'none'; resetGame(); };
    document.getElementById('restartBtn').onclick = () => { gameOverScreen.style.display = 'none'; resetGame(); };

    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') keys.left = true;
      if (e.key === 'ArrowRight') keys.right = true;
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft') keys.left = false;
      if (e.key === 'ArrowRight') keys.right = false;
    });

    function activateButton(id, key) {
      const btn = document.getElementById(id);
      ['touchstart', 'mousedown'].forEach(ev => btn.addEventListener(ev, e => { e.preventDefault(); keys[key] = true; }));
      ['touchend', 'mouseup', 'mouseleave'].forEach(ev => btn.addEventListener(ev, e => { e.preventDefault(); keys[key] = false; }));
    }

    activateButton('leftBtn', 'left');
    activateButton('rightBtn', 'right');
  </script>
</body>
</html>
